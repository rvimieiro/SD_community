Journal of Artificial Intelligence Research 35 (2009) 593‚Äì621

Submitted 02/09; published 07/09

Bounds Arc Consistency for Weighted CSPs
Matthias Zytnicki

Matthias.Zytnicki@versailles.inra.fr
INRA, UniteÃÅ de Recherche en GeÃÅnomique et Informatique
UR 1164, Versailles, France

Christine Gaspin
Simon de Givry
Thomas Schiex

Christine.Gaspin@toulouse.inra.fr
Simon.DeGivry@toulouse.inra.fr
Thomas.Schiex@toulouse.inra.fr

INRA, UniteÃÅ de BiomeÃÅtrie et Intelligence Artificielle
UR 875, Toulouse, France

Abstract
The Weighted Constraint Satisfaction Problem (WCSP) framework allows representing
and solving problems involving both hard constraints and cost functions. It has been applied to various problems, including resource allocation, bioinformatics, scheduling, etc. To
solve such problems, solvers usually rely on branch-and-bound algorithms equipped with
local consistency filtering, mostly soft arc consistency. However, these techniques are not
well suited to solve problems with very large domains. Motivated by the resolution of an
RNA gene localization problem inside large genomic sequences, and in the spirit of bounds
consistency for large domains in crisp CSPs, we introduce soft bounds arc consistency, a
new weighted local consistency specifically designed for WCSP with very large domains.
Compared to soft arc consistency, BAC provides significantly improved time and space
asymptotic complexity. In this paper, we show how the semantics of cost functions can
be exploited to further improve the time complexity of BAC. We also compare both in
theory and in practice the efficiency of BAC on a WCSP with bounds consistency enforced
on a crisp CSP using cost variables. On two different real problems modeled as WCSP,
including our RNA gene localization problem, we observe that maintaining bounds arc consistency outperforms arc consistency and also improves over bounds consistency enforced
on a constraint model with cost variables.

1. Introduction
The Weighted Constraint Satisfaction Problem (WCSP) is an extension of the crisp Constraint Satisfaction Problem (CSP) that allows the direct representation of hard constraints
and cost functions. The WCSP defines a simple optimization (minimization) framework
with a wide range of applications in resource allocation, scheduling, bioinformatics (SaÃÄnchez,
de Givry, & Schiex, 2008; Zytnicki, Gaspin, & Schiex, 2008), electronic markets (Sandholm,
1999), etc. It also captures fundamental AI and statistical problems such as Maximum
Probability Explanation in Bayesian nets and Markov Random Fields (Chellappa & Jain,
1993).
As in crisp CSP, the two main approaches to solve WCSP are inference and search.
This last approach is usually embodied in a branch-and-bound algorithm. This algorithm
estimates at each node of the search tree a lower bound of the cost of the solutions of the
sub-tree.
c 2009 AI Access Foundation. All rights reserved.

Zytnicki, Gaspin, de Givry & Schiex

One of the most successful approaches to build lower bounds has been obtained by
extending the notion of local consistency to WCSP (Meseguer, Rossi, & Schiex, 2006).
This includes soft AC (Schiex, 2000), AC* (Larrosa, 2002), FDAC* (Larrosa & Schiex,
2004), EDAC* (Heras, Larrosa, de Givry, & Zytnicki, 2005), OSAC (Cooper, de Givry,
& Schiex, 2007) and VAC (Cooper, de Givry, SaÃÄnchez, Schiex, & Zytnicki, 2008) among
others. Unfortunately, the worst case time complexity bounds of the associated enforcing
algorithms are at least cubic in the domain size and use an amount of space which is at
least linear in the domain size. This makes these consistencies useless for problems with
very large domains.
The motivation for designing a local consistency which can be enforced efficiently on
problems with large domains follows from our interest in the RNA gene localization problem. Initially modeled as a crisp CSP, this problem has been tackled using bounds consistency (Choi, Harvey, Lee, & Stuckey, 2006; Lhomme, 1993) and dedicated propagators
using efficient pattern matching algorithms (TheÃÅbault, de Givry, Schiex, & Gaspin, 2006).
The domain sizes are related to the size of the genomic sequences considered and can reach
hundreds of millions of values. In order to enhance this tool with scoring capabilities and
improved quality of localization, a shift from crisp to weighted CSP is a natural step which
requires the extension of bounds consistency to WCSP. Beyond this direct motivation, this
extension is also useful in other domains where large domains occur naturally such as temporal reasoning or scheduling.
The local consistencies we define combine the principles of bounds consistency with the
principles of soft local consistencies. These definitions are general and are not restricted
to binary cost functions. The corresponding enforcing algorithms improve over the time
and space complexity of AC* by a factor of d and also have the nice but rare property, for
WCSP local consistencies, of being confluent.
As it has been done for AC-5 by Van Hentenryck, Deville, and Teng (1992) for functional
or monotonic constraints, we show that different forms of cost functions (largely captured
by the notion of semi-convex cost functions) can be processed more efficiently. We also
show that the most powerful of these bounds arc consistencies is strictly stronger than the
application of bounds consistency to the reified representation of the WCSP as proposed
by Petit, ReÃÅgin, and BessieÃÄre (2000).
To conclude, we experimentally compare the efficiency of algorithms that maintain these
different local consistencies inside branch-and-bound on agile satellite scheduling problems (Verfaillie & Lemaƒ±ÃÇtre, 2001) and RNA gene localization problems (Zytnicki et al.,
2008) and observe clear speedups compared to different existing local consistencies.

2. Definitions and Notations
This section will introduce the main notions that will be used throughout the paper. We
will define the (Weighted) Constraint Satisfaction Problems, as well as a local consistency
property frequently used for solving the Weighted Constraint Satisfaction Problem: arc
consistency (AC*).
594

Bounds Arc Consistency for Weighted CSPs

2.1 Constraint Networks
Classic and weighted constraint networks share finite domain variables as one of their components. In this paper, the domain of a variable xi is denoted by D(xi ). To denote a value in
D(xi ), we use an index i as in vi , vi‚Ä≤ ,. . . For each variable xi , we assume that the domain of xi
is totally ordered by ‚â∫i and we denote by inf(xi ) and sup(xi ) the minimum (resp. maximum)
values of the domain D(xi ). An assignment tS of a set of variables S = {xi1 , . . . , xir } is a
function that maps variables to elements of their domains: tS = (xi1 ‚Üê vi1 , . . . , xir ‚Üê vir )
with ‚àÄi ‚àà {i1 , . . . , ir }, tS (xi ) = vi ‚àà D(xi ). For a given assignment tS such that xi ‚àà S, we
simply say that a value vi ‚àà D(xi ) belongs to tS to mean that tS (xi ) = vi . We denote by
‚ÑìS , the set of all possible assignments on S.
Definition 2.1 A constraint network (CN) is a tuple P = hX , D, Ci, where X = {x1 , . . . , xn }
is a set of variables and D = {D(x1 ), . . . , D(xn )} is the set of the finite domains of each
variable. C is a set of constraints. A constraint cS ‚àà C defines the set of all authorized
combinations of values for the variables in S as a subset of ‚ÑìS . S is called the scope of cS .
|S| is called the arity of cS . For simplicity, unary (arity 1) and binary (arity 2) constraints
may be denoted by ci and cij instead of c{xi } and c{xi ,xj } respectively. We denote by d the
maximum domain size, n, the number of variables in the network and e, the number of
constraints. The central problem on constraint networks is to find a solution, defined as
an assignment tX of all variables such that for any constraint cS ‚àà C, the restriction of tX
to S is authorized by cS (all constraints are satisfied). This is the Constraint Satisfaction
Problem (CSP).
Definition 2.2 Two CNs with the same variables are equivalent if they have the same set
of solutions.
A CN will be said to be ‚Äúempty‚Äù if one of its variables has an empty domain. This
may happen following local consistency enforcement. For CN with large domains, the use
of bounds consistency is the most usual approach. Historically, different variants of bounds
consistency have been introduced, generating some confusion. Using the terminology introduced by Choi et al. (2006), the bounds consistency considered in this paper is the
bounds(D) consistency. Because we only consider large domains defining intervals, this is
actually equivalent to bounds(Z) consistency. For simplicity, in the rest of the paper we
denote this as ‚Äúbounds consistency‚Äù.
Definition 2.3 (Bounds consistency) A variable xi is bounds consistent iff every constraint cS ‚àà C such that xi ‚àà S contains a pair of assignments (t, t‚Ä≤ ) ‚àà ‚ÑìS √ó ‚ÑìS such that
inf(xi ) ‚àà t and sup(xi ) ‚àà t‚Ä≤ . In this case, t and t‚Ä≤ are called the supports of the two bounds
of xi ‚Äôs domain.
A CN is bounds consistent iff all its variables are bounds consistent.
To enforce bounds consistency on a given CN, any domain bound that does not satisfy
the above properties is deleted until a fixed point is reached.
595

Zytnicki, Gaspin, de Givry & Schiex

2.2 Weighted Constraint Networks
Weighted constraint networks are obtained by using cost functions (also referred as ‚Äúsoft
constraints‚Äù) instead of constraints.
Definition 2.4 A weighted constraint network (WCN) is a tuple P = hX , D, W, ki, where
X = {x1 , . . . , xn } is a set of variables and D = {D(x1 ), . . . , D(xn )} is the set of the finite
domains of each variable. W is a set of cost functions. A cost function wS ‚àà W associates
an integer cost wS (tS ) ‚àà [0, k] to every assignment tS of the variables in S. The positive
number k defines a maximum (intolerable) cost.
The cost k, which may be finite or infinite, is the cost associated with forbidden assignments. This cost is used to represent hard constraints. Unary and binary cost functions
may be denoted by wi and wij instead of w{xi } and w{xi ,xj } respectively. As usually for
WCNs, we assume the existence of a zero-arity cost function, w‚àÖ ‚àà [0, k], a constant cost
whose initial value is usually equal to 0. The cost of an assignment tX of all variables is
obtained by combining the costs of all the cost functions wS ‚àà W applied to the restriction
of tX to S. The combination is done using the function ‚äï defined as a ‚äï b = min(k, a + b).
Definition 2.5 A solution of a WCN is an assignment tX of all variables whose cost is
less than k. It is optimal if no other assignment of X has a strictly lower cost.
The central problem in WCN is to find an optimal solution.
Definition 2.6 Two WCNs with the same variables are equivalent if they give the same
cost to any assignments of all their variables.
Initially introduced by Schiex (2000), the extension of arc consistency to WCSP has
been refined by Larrosa (2002) leading to the definition of AC*. It can be decomposed into
two sub-properties: node and arc consistency itself.
Definition 2.7 (Larrosa, 2002) A variable xi is node consistent iff:
‚Ä¢ ‚àÄvi ‚àà D(xi ), w‚àÖ ‚äï wi (vi ) < k.
‚Ä¢ ‚àÉvi ‚àà D(xi ) such that wi (vi ) = 0. The value vi is called the unary support of xi .
A WCN is node consistent iff every variable is node consistent.
To enforce NC on a WCN, values that violate the first property are simply deleted.
Value deletion alone is not capable of enforcing the second property. As shown by Cooper
and Schiex (2004), the fundamental mechanism required here is the ability to move costs
between different scopes. A cost b can be subtracted from a greater cost a by the function
‚äñ defined by a ‚äñ b = (a ‚àí b) if a 6= k and k otherwise. Using ‚äñ, a unary support for a
variable xi can be created by subtracting the smallest unary cost minvi ‚ààD(xi ) wi (vi ) from
all wi (vi ) and adding it (using ‚äï) to w‚àÖ. This operation that shifts costs from variables
to w‚àÖ, creating a unary support, is called a projection from wi to w‚àÖ. Because ‚äñ and ‚äï
cancel out, defining a fair valuation structure (Cooper & Schiex, 2004), the obtained WCN
is equivalent to the original one. This equivalence preserving transformation (Cooper and
Schiex) is more precisely described as the ProjectUnary() function in Algorithm 1.
We are now able to define arc and AC* consistency on WCN.
596

Bounds Arc Consistency for Weighted CSPs

Algorithm 1: Projections at unary and binary levels
1
2
3
4
5
6
7
8
9
10

Procedure ProjectUnary(xi )
min ‚Üê minvi ‚ààD(xi ) {wi (vi )} ;
if (min = 0) then return;
foreach vi ‚àà D(xi ) do wi (vi ) ‚Üê wi (vi ) ‚äñ min ;
w‚àÖ ‚Üê w‚àÖ ‚äï min ;

[ Find the unary support of xi ]

Procedure Project(xi , vi , xj )
[ Find the support of vi w.r.t. wij ]
min ‚Üê minvj ‚ààD(xj ) {wij (vi , vj )} ;
if (min = 0) then return;
foreach vj ‚àà D(xj ) do wij (vi , vj ) ‚Üê wij (vi , vj ) ‚äñ min ;
wi (vi ) ‚Üê wi (vi ) ‚äï min ;

Definition 2.8 A variable xi is arc consistent iff for every cost function wS ‚àà W such that
xi ‚àà S, and for every value vi ‚àà D(xi ), there exists an assignment t ‚àà ‚ÑìS such that vi ‚àà t
and wS (t) = 0. The assignment t is called the support of vi on wS . A WCN is AC* iff
every variable is arc and node consistent.
To enforce arc consistency, a support for a given value vi of xi on a cost function wS
can be created by subtracting (using ‚äñ) the cost mint‚àà‚ÑìS ,vi ‚ààt wS (t) from the costs of all
assignments containing vi in ‚ÑìS and adding it to wi (vi ). These cost movements, applied
for all values vi of D(xi ), define the projection from wS to wi . Again, this transformation
preserves equivalence between problems. It is more precisely described (for simplicity, in
the case of binary cost functions) as the Project() function in Algorithm 1.

Example 2.9 Consider the WCN in Figure 1(a). It contains two variables (x1 and x2 ),
each with two possible values (a and b, represented by vertices). A unary cost function is
associated with each variable, the cost of a value being represented inside the corresponding
vertex. A binary cost function between the two variables is represented by weighted edges
connecting pairs of values. The absence of edge between two values represents a zero cost.
Assume k is equal to 4 and w‚àÖ is equal to 0.
Since the cost w1 (x1 ‚Üê a) is equal to k, the value a can be deleted from the domain
of x1 (by NC, first property). The resulting WCN is represented in Figure 1(b). Then,
since x2 has no unary support (second line of the definition of NC), we can project a cost
of 1 to w‚àÖ (cf. Figure 1(c)). The instance is now NC. To enforce AC*, we project 1 from
the binary cost function w12 to the value a of x1 since this value has no support on w12
(cf. Figure 1(d)). Finally, we project 1 from w1 to w‚àÖ, as seen on Figure 1(e). Ultimately,
we note that the value b of x2 has no support. To enforce AC*, we project a binary cost
of 1 to this value and remove it since it has a unary cost of 2 which, combined with w‚àÖ
reaches k = 4.

597

Zytnicki, Gaspin, de Givry & Schiex

w‚àÖ = 0, k = 4
x1
x2

w‚àÖ = 0, k = 4
x2
x1
a

1

4

a

1

a

1

0

2

b

2

b

a
1

0

2

2

b

b

0

a

a

1

b

b

0

1

0

x1

0

a

a

1

b

b

(e) find unary support using
ProjectUnary(x1 )

(d) find support for (x1 ‚Üê
b) using Project(x1 , b, x2 )
(AC*)

0

a

2

1

b

(c) find unary support using
ProjectUnary(x2 ) (NC*)

w‚àÖ = 2, k = 4
x2
x1

w‚àÖ = 1, k = 4
x1
x2

1

a
1

(b) prune forbidden values
(NC*)

(a) original instance

b

a

1

1

b

w‚àÖ = 1, k = 4
x2
x1

w‚àÖ = 2, k = 4
x2
0

0

a
b

(f) Arc consistency enforced

Figure 1: Enforcing Arc Consistency.

3. Bounds Arc Consistency (BAC)
In crisp CSP, the bounds consistency enforcing process just deletes bounds that are not
supported in one constraint. In weighted CSP, enforcement is more complex. If a similar
value deletion process exists based on the first node consistency property violation (whenever
w‚àÖ ‚äï wi (vi ) reaches k), additional cost movements are performed to enforce node and arc
consistency.
As shown for AC*, these projections require the ability to represent an arbitrary unary
cost function wi for every variable xi . This requires space in O(d) in general since projections
can lead to arbitrary changes in the original wi cost function (even if they have an efficient
internal representation). To prevent this, we therefore avoid to move cost from cost functions
with arity greater than one to unary constraints. Instead of such projections, we only keep
a value deletion mechanism applied to the bounds of the current domain that takes into
account all the cost functions involving the variable considered. For a given variable xi
involved in a cost function wS , the choice of a given value vi will at least induce a cost
increase of mintS ‚àà‚ÑìS ,vi ‚ààtS wS (tS ). If these minimum costs, combined on all the cost functions
involving xi , together with w‚àÖ, reach the intolerable cost of k, then the value can be deleted.
As in bounds consistency, this is just done for the two bounds of the domain. This leads to
the following definition of BAC (bounds arc consistency) in WCSP:
Definition 3.1 In a WCN P = hX , D, W, ki, a variable xi is bounds arc consistent iff:


X
wS (tS ) < k
w‚àÖ ‚äï
min
tS ‚àà‚ÑìS ,inf(xi )‚ààtS

wS ‚ààW,xi ‚ààS

w‚àÖ ‚äï

X

wS ‚ààW,xi ‚ààS



min

tS ‚àà‚ÑìS ,sup(xi )‚ààtS


wS (tS ) < k

A WCN is bounds arc consistent if every variable is bounds arc consistent.
598

Bounds Arc Consistency for Weighted CSPs

One can note that this definition is a proper generalization of bounds consistency since
when k = 1, it is actually equivalent to the definition of bounds(D) consistency for crisp
CSP (Choi et al., 2006) (also equivalent to bounds(Z) consistency since domains are defined
as intervals).
The algorithm enforcing BAC is described as Algorithm 2. Because enforcing BAC only
uses value deletion, it is very similar in structure to bounds consistency enforcement. We
maintain a queue Q of variables whose domain has been modified (or is untested). For
better efficiency, we use extra data-structures to efficiently maintain the combined cost associated with the domain bound inf(xi ), denoted winf (xi ). For a cost function wS involving
xi , the contribution of wS to this combined cost is equal to mintS ‚àà‚ÑìS ,inf(xi )‚ààtS wS (tS ). This
contribution is maintained in a data-structure ‚àÜinf (xi , wS ) and updated whenever the minimum cost may change because of value removals. Notice that, in Algorithm 2, the line 14
is a concise way to denote the hidden loops which initialize the winf , wsup , ‚àÜinf and ‚àÜsup
data-structures to zero.
Domain pruning is achieved by function PruneInf() which also resets the data-structures
associated with the variable at line 35 and these data-structures are recomputed when the
variable is extracted from the queue. Indeed, inside the loop of line 20, the contributions
‚àÜinf (xi , wS ) to the cost winf (xi ) from the cost functions wS involving xj are reset. The
Function pop removes an element from the queue and returns it.
Proposition 3.2 (Time and space complexity) For a WCN with maximum arity r of
the constraints, enforcing BAC with Algorithm 2 is time O(er2 dr ) and space O(n + er).
Proof: Regarding time, every variable can be pushed into Q at most d + 1 times: once
at the beginning, and when one of its values has been removed. As a consequence, the
foreach loop on line 18 iterates O(erd) times, and the foreach loop on line 20 iterates
O(er2 d) times. The min computation on line 22 takes time O(dr‚àí1 ) and thus, the overall
time spent at this line takes time O(er2 dr ). PruneInf() is called at most O(er2 d) times.
The condition on line 32 is true at most O(nd) times and so, line 35 takes time O(ed)
(resetting ‚àÜinf (xi , ¬∑) on line 35 hides a loop on all cost functions involving xi ). The total
time complexity is thus O(er2 dr ).
Regarding space, we only used winf , wsup and ‚àÜ data-structures. The space complexity
is thus O(n + er).

Note that exploiting the information of last supports as in AC2001 (BessieÃÄre & ReÃÅgin,
2001) does not reduce the worst-case time complexity because the minimum cost of a cost
function must be recomputed from scratch each time a domain has been reduced and the
last support has been lost (Larrosa, 2002). However, using last supports helps in practice
to reduce mean computation time and this has been done in our implementation.
Compared to AC*, which can be enforced in O(n2 d3 ) time and O(ed) space for binary
WCN, BAC can be enforced d times faster, and the space complexity becomes independent
of d which is a requirement for problems with very large domains.
Another interesting difference with AC* is that BAC is confluent ‚Äî just as bounds
consistency is. Considering AC*, it is known that there may exist several different AC*
closures with possibly different associated lower bounds w‚àÖ (Cooper & Schiex, 2004). Note
that although OSAC (Cooper et al., 2007) is able to find an optimal w‚àÖ (at much higher
599

Zytnicki, Gaspin, de Givry & Schiex

Algorithm 2: Algorithm enforcing BAC.
11
12
14
15
16
18
20
22
23
24
25
26
27
28
29

30
32
33
35
36
37
38
39
40
41
42
43

Procedure BAC(X , D, W, k)
Q‚ÜêX ;
winf (¬∑) ‚Üê 0 ; wsup (¬∑) ‚Üê 0 ; ‚àÜinf (¬∑, ¬∑) ‚Üê 0 ; ‚àÜsup (¬∑, ¬∑) ‚Üê 0 ;
while (Q 6= ‚àÖ) do
xj ‚Üê pop(Q) ;
foreach wS ‚àà W, xj ‚àà S do
foreach xi ‚àà S do
Œ± ‚Üê mintS ‚àà‚ÑìS ,inf(xi )‚ààtS wS (tS ) ;
winf (xi ) ‚Üê winf (xi ) ‚äñ ‚àÜinf (xi , wS ) ‚äï Œ± ;
‚àÜinf (xi , wS ) ‚Üê Œ± ;
if PruneInf(xi ) then Q ‚Üê Q ‚à™ {xi } ;
Œ± ‚Üê mintS ‚àà‚ÑìS ,sup(xi )‚ààtS wS (tS ) ;
wsup (xi ) ‚Üê wsup (xi ) ‚äñ ‚àÜsup (xi , wS ) ‚äï Œ± ;
‚àÜsup (xi , wS ) ‚Üê Œ± ;
if PruneSup(xi ) then Q ‚Üê Q ‚à™ {xi } ;
Function PruneInf(xi ) : boolean
if (w‚àÖ ‚äï winf (xi ) = k) then
delete inf(xi ) ;
winf (xi ) ‚Üê 0 ; ‚àÜinf (xi , ¬∑) ‚Üê 0 ;
return true;
else return false;
Function PruneSup(xi ) : boolean
if (w‚àÖ ‚äï wsup (xi ) = k) then
delete sup(xi ) ;
wsup (xi ) ‚Üê 0 ; ‚àÜsup (xi , ¬∑) ‚Üê 0 ;
return true;
else return false;

600

Bounds Arc Consistency for Weighted CSPs

computational cost), it is still not confluent. The following property shows that BAC is
confluent.
Proposition 3.3 (Confluence) Enforcing BAC on a given problem always leads to a
unique WCN.
Proof: We will prove the proposition as follows. We will first define a set of problems
which contains all the problems that can be reached from the original WCN through BAC
enforcement. Notice that, at each step of BAC enforcement, in the general case, several
operations can be performed and no specific order is imposed. Therefore, a set of problems
can be reached at each step. We will show that the set of problems has a lattice structure
and ultimately show that the closure of BAC is the lower bound of this lattice, and is
therefore unique, which proves the property. This proof technique is usual for proving
convergence of the chaotic iteration of a collection of suitable functions and has been used
for characterizing CSP local consistency by Apt (1999).
During the enforcement of BAC, the original problem P = hX , D, W, ki is iteratively
transformed into a set of different problems which are all equivalent to P, and obtained
by deleting values violating BAC. Because these problems are obtained by value removals,
they belong to the set ‚Ñò1 (P ) defined by: {hX , D‚Ä≤ , W, ki : D‚Ä≤ ‚äÜ D}.
We now define a relation, denoted ‚äë, on the set ‚Ñò1 (P ):
‚àÄ(P1 , P2 ) ‚àà ‚Ñò21 (P), P1 ‚äë P2 ‚áî ‚àÄi ‚àà [1, n], D1 (xi ) ‚äÜ D2 (xi )
It is easy to see that this relation defines a partial order. Furthermore, each pair of
elements has a greatest lower bound glb and a least upper bound lub in ‚Ñò1 (P), defined by:
‚àÄ(P1 , P2 ) ‚àà ‚Ñò21 (P),
glb(P1 , P2 ) = hX , {D1 (xi ) ‚à© D2 (xi ) : i ‚àà [1, n]}, W, ki ‚àà ‚Ñò1 (P)
lub(P1 , P2 ) = hX , {D1 (xi ) ‚à™ D2 (xi ) : i ‚àà [1, n]}, W, ki ‚àà ‚Ñò1 (P)
h‚Ñò1 (P), ‚äëi is thus a complete lattice.
BAC filtering works by removing values violating the BAC properties, transforming
an original problem into a succession of equivalent problems. Each transformation can be
described by the application of dedicated functions from ‚Ñò1 (P) to ‚Ñò1 (P). More precisely,
there are two such functions for each variable, one for the minimum bound inf(xi ) of the
domain of xi and a symmetrical one for the maximum bound. For inf(xi ), the associated
function keeps the instance unchanged if inf(xi ) satisfies the condition of Definition 3.1 and
it otherwise returns a WCN where inf(xi ) alone has been deleted. The collection of all those
functions defines a set of functions from ‚Ñò1 (P ) to ‚Ñò1 (P ) which we denote by FBAC .
Obviously, every function f ‚àà FBAC is order preserving:
‚àÄ(P1 , P2 ) ‚àà ‚Ñò21 (P), P1 ‚äë P2 ‚áí f (P1 ) ‚äë f (P2 )
By application of the Tarski-Knaster theorem (Tarski, 1955), it is known that every
function f ‚àà FBAC (applied until quiescence during BAC enforcement) has at least one
fixpoint, and that the set of these fixed points forms a lattice for ‚äë. Moreover, the intersection of the lattices of fixed points of the functions f ‚àà FBAC , denoted by ‚Ñò‚ãÜ1 (P), is also
601

Zytnicki, Gaspin, de Givry & Schiex

a lattice. ‚Ñò‚ãÜ1 (P) is not empty since the problem hX , {‚àÖ, . . . , ‚àÖ}, Wi is a fixpoint for every
filtering function in FBAC . ‚Ñò‚ãÜ1 (P) is exactly the set of fixed points of FBAC .
We now show that, if the algorithm reaches a fixpoint, it reaches the greatest element
of ‚Ñò‚ãÜ1 (P). We will prove by induction that any successive application of elements of FBAC
on P yields problems which are greater than any element of ‚Ñò‚ãÜ1 (P) for the order ‚äë. Let
us consider any fixpoint P ‚ãÜ of ‚Ñò‚ãÜ1 (P). Initially, the algorithm applies on P, which is the
greatest element of ‚Ñò1 (P), and thus P ‚ãÜ ‚äë P. This is the base case of the induction. Let
us now consider any problem P1 obtained during the execution of the algorithm. We have,
by induction, P ‚ãÜ ‚äë P1 . Since ‚äë is order preserving, we know that, for any function f of
FBAC , f (P ‚ãÜ ) = P ‚ãÜ ‚äë f (P1 ). This therefore proves the induction.
To conclude, if the algorithm terminates, then it gives the maximum element of ‚Ñò‚ãÜ1 (P).
Since proposition 3.2 showed that the algorithm actually terminates, we can conclude that
it is confluent.

If enforcing BAC may reduce domains, it never increases the lower bound w‚àÖ. This is an
important limitation given that each increase in w‚àÖ may generate further value deletions and
possibly, failure detection. Note that even when a cost function becomes totally assigned,
the cost of the corresponding assignment is not projected to w‚àÖ by BAC enforcement. This
can be simply done by maintaining a form of backward checking as in the most simple
WCSP branch-and-bound algorithm (Freuder & Wallace, 1992). To go beyond this simple
approach, we consider the combination of BAC with another WCSP local consistency which,
similarly to AC*, requires cost movements to be enforced but which avoids the modification
of unary cost functions to keep a reasonable space complexity. This is achieved by directly
moving costs to w‚àÖ.

4. Enhancing BAC
In many cases, BAC may be very weak compared to AC* in situations where it seems to
be possible to infer a decent w‚àÖ value. Consider for example the following cost function:

D(x1 ) √ó D(x2 ) ‚Üí
E
D(x1 ) = D(x2 ) = [1, 10]
w12 :
(v1 , v2 )
7‚Üí v1 + v2
AC* can increase w‚àÖ by 2, by projecting a cost of 2 from w12 to the unary constraint w1
on every value, and then projecting these costs from w1 to w‚àÖ by enforcing NC. However,
if w‚àÖ = w1 = w2 = 0 and k is strictly greater than 11, BAC remains idle here. We can
however simply improve BAC by directly taking into account the minimum possible cost of
the cost function w12 over all possible assignments given the current domains.
Definition 4.1 A cost function wS is ‚àÖ-inverse consistent (‚àÖ-IC) iff:
‚àÉtS ‚àà ‚ÑìS , wS (tS ) = 0
Such a tuple tS is called a support for wS . A WCN is ‚àÖ-IC iff every cost function (except
w‚àÖ) is ‚àÖ-IC.
Enforcing ‚àÖ-IC can always be done as follows: for every cost function wS with a non
empty scope, the minimum cost assignment of wS given the current variable domains is
602

Bounds Arc Consistency for Weighted CSPs

computed. The cost Œ± of this assignment is then subtracted from all the tuple costs in wS
and added to w‚àÖ. This creates at least one support in wS and makes the cost function
‚àÖ-IC. For a given cost function wS , this is done by the Project() function of Algorithm 3.
In order to strengthen BAC, a natural idea is to combine it with ‚àÖ-IC. We will call BAC‚àÖ
the resulting combination of BAC and ‚àÖ-IC. To enforce BAC‚àÖ, the previous algorithm
is modified by first adding a call to the Project() function (see line 53 of Algorithm 3).
Moreover, to maintain BAC whenever w‚àÖ is modified by projection, every variable is tested
for possible pruning at line 66 and put back in Q in case of domain change. Note that
the subtraction applied to all constraint tuples at line 75 can be done in constant time
without modifying the constraint by using an additional ‚àÜwS data-structure, similar to
the ‚àÜ data-structure introduced by Cooper and Schiex (2004). This data-structure keeps
track of the cost which has been projected from wS to w‚àÖ. This feature makes it possible
to leave the original costs unchanged during the enforcement of the local consistency. For
example, for any tS ‚àà ‚ÑìS , wS (t) refers to wS (t) ‚äñ ‚àÜwS , where wS (t) denotes the original
cost. Note that ‚àÜwS , which will be later used in a confluence proof, precisely contains the
amount of cost which has been moved from wS to w‚àÖ. The whole algorithm is described
in Algorithm 3. We highlighted in black the parts which are different from Algorithm 2
whereas the unchanged parts are in gray.
Proposition 4.2 (Time and space complexity) For a WCN with maximum arity r of
the constraints, enforcing BAC‚àÖ with Algorithm 3 can be enforced in O(n2 r2 dr+1 ) time
using O(n + er) memory space.
Proof: Every variable is pushed at most O(d) times in Q, thus the foreach at line 51
(resp. line 55) loops at most O(erd) (resp. O(er2 d)) times. The projection on line 53 takes
O(dr ) time. The operation at line 57 can be carried out in O(dr‚àí1 ) time. The overall time
spent inside the if of the PruneInf() function is bounded by O(ed). Thus the overall time
spent in the loop at line 51 (resp. line 55) is bounded by O(er2 dr+1 ) (resp. O(er2 dr )).
The flag on line 66 is true when w‚àÖ increases, and so it cannot be true more than k times
(assuming integer costs). If the flag is true, then we spend O(n) time to check all the bounds
of the variables. Thus, the time complexity under the if is bounded by O(min{k, nd} √ó n).
To sum up, the overall time complexity is O(er2 dr+1 + min{k, nd} √ó n), which is bounded
by O(n2 r2 dr+1 ).
The space complexity is given by the ‚àÜ, winf , wsup and ‚àÜwS data-structures which sums
up to O(n + re) for a WCN with an arity bounded by r.

The time complexity of the algorithm enforcing BAC‚àÖ is multiplied by d compared
to BAC without ‚àÖ-IC. This is a usual trade-off between the strength of a local property
and the time spent to enforce it. However, the space complexity is still independent of d.
Moreover, like BAC, BAC‚àÖ is confluent.
Proposition 4.3 (Confluence) Enforcing BAC‚àÖ on a given problem always leads to a
unique WCN.
Proof: The proof is similar to the proof of Proposition 3.3. However, because of the
possible cost movements induced by projections, BAC‚àÖ transforms the original problem P
in more complex ways, allowing either pruning domains (BAC) or moving costs from cost
603

Zytnicki, Gaspin, de Givry & Schiex

Algorithm 3: Algorithm enforcing BAC‚àÖ
44
45
46
47
48
49
51
53
55
57
58
59
60
61
62
63
64
66
67
68
69

70
71
72
73
75
76
77

Procedure BAC‚àÖ(X , D, W, k)
Q‚ÜêX ;
winf (¬∑) ‚Üê 0 ; wsup (¬∑) ‚Üê 0 ; ‚àÜinf (¬∑, ¬∑) ‚Üê 0 ; ‚àÜsup (¬∑, ¬∑) ‚Üê 0 ;
while (Q 6= ‚àÖ) do
xj ‚Üê pop(Q) ;
flag ‚Üê false ;
foreach wS ‚àà W, xj ‚àà S do
if Project(wS ) then flag ‚Üê true ;
foreach xi ‚àà S do
Œ± ‚Üê mintS ‚àà‚ÑìS ,inf(xi )‚ààtS wS (tS ) ;
winf (xi ) ‚Üê winf (xi ) ‚äñ ‚àÜinf (xi , wS ) ‚äï Œ± ;
‚àÜinf (xi , wS ) ‚Üê Œ± ;
if PruneInf(xi ) then Q ‚Üê Q ‚à™ {xi } ;
Œ± ‚Üê mintS ‚àà‚ÑìS ,sup(xi )‚ààtS wS (tS ) ;
wsup (xi ) ‚Üê wsup (xi ) ‚äñ ‚àÜsup (xi , wS ) ‚äï Œ± ;
‚àÜsup (xi , wS ) ‚Üê Œ± ;
if PruneSup(xi ) then Q ‚Üê Q ‚à™ {xi } ;
if (flag) then
foreach xi ‚àà X do
if PruneInf(xi ) then Q ‚Üê Q ‚à™ {xi } ;
if PruneSup(xi ) then Q ‚Üê Q ‚à™ {xi } ;
Function Project(wS ) : boolean
Œ± ‚Üê mintS ‚àà‚ÑìS wS (tS ) ;
if (Œ± > 0) then
w‚àÖ ‚Üê w‚àÖ ‚äï Œ± ;
wS (¬∑) ‚Üê wS (¬∑) ‚äñ Œ± ;
return true;
else return false;

604

Bounds Arc Consistency for Weighted CSPs

functions to w‚àÖ. The set of problems that will be considered needs therefore to take this
into account. Instead of being just defined by its domains, a WCN reached by BAC‚àÖ is
also characterized by the amount of cost that has been moved from each cost function wS
to w‚àÖ. This quantity is already denoted by ‚àÜwS in Section 4, on page 603. We therefore
consider the set ‚Ñò2 (P) defined by:

(hX , D‚Ä≤ , W, ki, {‚àÜw : w ‚àà W}) : ‚àÄi ‚àà [1, n], D‚Ä≤ (xi ) ‚äÜ D(xi ), ‚àÄw ‚àà W, ‚àÜw ‚àà [0, k]
We can now define the relation ‚äë on ‚Ñò2 (P):

w
P1 ‚äë P2 ‚áî ((‚àÄw ‚àà W, ‚àÜw
1 ‚â• ‚àÜ2 ) ‚àß (‚àÄxi ‚àà X , D1 (xi ) ‚äÜ D2 (xi )))

This relation is reflexive, transitive and antisymmetric. The first two properties can be
easily verified. Suppose now that (P1 , P2 ) ‚àà ‚Ñò22 (P) and that (P1 ‚äë P2 ) ‚àß (P2 ‚äë P1 ). We
have thus (‚àÄw ‚àà W, ‚àÜw = ‚àÜ‚Ä≤w )‚àß(‚àÄxi ‚àà X , D(xi ) = D‚Ä≤ (xi )). This ensures that the domains,
as well as the amounts of cost projected by each cost function, are the same. Thus, the
problems are the same and ‚äë is antisymmetric.
Besides, h‚Ñò2 (P), ‚äëi is a complete lattice, since:
‚àÄ(P1 , P2 ) ‚àà ‚Ñò22 (P),
w
glb(P1 , P2 ) = (hX , {D1 (xi ) ‚à© D2 (xi ) : i ‚àà [1, n]}, W, ki, {max{‚àÜw
1 , ‚àÜ2 } : w ‚àà W})
w
lub(P1 , P2 ) = (hX , {D1 (xi ) ‚à™ D2 (xi ) : i ‚àà [1, n]}, W, ki, {min{‚àÜw
1 , ‚àÜ2 } : w ‚àà W})

and both of them are in ‚Ñò2 (P).
Every enforcement of BAC‚àÖ follows from the application of functions from a set of functions FBAC ‚àÖ which may remove the maximum or minimum domain bound (same definition
as for BAC) or may project cost from cost functions to w‚àÖ. For a given cost function
w ‚àà W, such a function keeps the instance unchanged if the minimum Œ± of w is 0 over
possible tuples. Otherwise, if Œ± > 0, the problem returned is derived from P by projecting
an amount of cost Œ± from w to w‚àÖ. These functions are easily shown to be order preserving
for ‚äë.
As in the proof of Proposition 3.3, we can define the lattice ‚Ñò‚ãÜ2 (P), which is the intersection of the sets of fixed points of the functions f ‚àà FBAC ‚àÖ . ‚Ñò‚ãÜ2 (P) is not empty, since
(hX , {‚àÖ, . . . , ‚àÖ}, W, ki, {k, . . . , k}) is in it. As in the proof of proposition 3.3, and since Algorithm 3 terminates, we can conclude that this algorithm is confluent, and that it results
in lub(‚Ñò‚ãÜ2 (P)).


5. Exploiting Cost Function Semantics in BAC‚àÖ
In crisp AC, several classes of binary constraints make it possible to enforce AC significantly
faster (in O(ed) instead of O(ed2 ), as shown by Van Hentenryck et al., 1992). Similarly,
it is possible to exploit the semantics of the cost functions to improve the time complexity
of BAC‚àÖ enforcement. As the proof of Proposition 4.2 shows, the dominating factors in
this complexity comes from the complexity of computing the minimum of cost functions
during projection at lines 53 and 57 of Algorithm 3. Therefore, any cost function property
605

Zytnicki, Gaspin, de Givry & Schiex

that makes these computations less costly may lead to an improvement of the overall time
complexity.
Proposition 5.1 In a binary WCN, if for any cost function wij ‚àà W and for any subintervals Ei ‚äÜ D(xi ), Ej ‚äÜ D(xj ), the minimum of wij over Ei √ó Ej can be found in time
O(d), then the time complexity of enforcing BAC‚àÖ is O(n2 d2 ).
Proof: This follows directly from the proof of Proposition 4.2. In this case, the complexity
of projection at line 53 is only in O(d) instead of O(d2 ). Thus the overall time spent in the
loop at line 51 is bounded by O(ed2 ) and the overall complexity is O(ed2 + n2 d) ‚â§ O(n2 d2 ).

Proposition 5.2 In a binary WCN, if for any cost function wij ‚àà W and for any subintervals Ei ‚äÜ D(xi ), Ej ‚äÜ D(xj ), the minimum of wij over Ei √ó Ej can be found in
constant time, then the time complexity of enforcing BAC‚àÖ is O(n2 d).
Proof: This follows again from the proof of Proposition 4.2. In this case, the complexity
of projection at line 53 is only in O(1) instead of O(d2 ). Moreover, the operation at line 57
can be carried out in time O(1) instead of O(d). Thus, the overall time spent in the loop
at line 51 is bounded by O(ed) and the overall complexity is O(ed + n2 d) = O(n2 d).

These two properties are quite straightforward and one may wonder if they have non
trivial usage. They can actually be directly exploited to generalize the results presented
by Van Hentenryck et al. (1992) for functional, anti-functional and monotonic constraints.
In the following sections, we show that functional, anti-functional and semi-convex cost functions (which include monotonic cost functions) can indeed benefit from an O(d) speedup
factor by application of Proposition 5.1. For monotonic cost functions and more generally
any convex cost function, a stronger speedup factor of O(d2 ) can be obtained by Proposition 5.2.
5.1 Functional Cost Functions
The notion of functional constraint can be extended to cost functions as follows:
Definition 5.3 A cost function wij is functional w.r.t. xi iff:
‚Ä¢ ‚àÄ(vi , vj ) ‚àà D(xi ) √ó D(xj ), wij (vi , vj ) ‚àà {0, Œ±} with Œ± ‚àà [1, k]
‚Ä¢ ‚àÄvi ‚àà D(xi ), there is at most one value vj ‚àà D(xj ) such that wij (vi , vj ) = 0. When it
exists, this value is called the functional support of vi .
We assume in the rest of the paper that the functional
support can be computed in constant
(
0 if xi = xj
= =
time. For example, the cost function wij
is functional. In this case, the
1 otherwise
functional support of vi is itself. Note that for k = 1, functional cost functions represent
functional constraints.
Proposition 5.4 The minimum of a functional cost function wij w.r.t. xi can always be
found in O(d).
606

Bounds Arc Consistency for Weighted CSPs

Proof: For every value vi of xi , one can just check if the functional support of vi belongs
to the domain of xj . This requires O(d) checks. If this is never the case, then the minimum
of the cost function is known to be Œ±. Otherwise, it is 0. The result follows.

5.2 Anti-Functional and Semi-Convex Cost Functions
Definition 5.5 A cost function wij is anti-functional w.r.t. the variable xi iff:
‚Ä¢ ‚àÄ(vi , vj ) ‚àà D(xi ) √ó D(xj ), wij (vi , vj ) ‚àà {0, Œ±} with Œ± ‚àà [1, k]
‚Ä¢ ‚àÄvi ‚àà D(xi ), there is at most one value vj ‚àà D(xj ) such that wij (vi , vj ) = Œ±. When it
exists, this value is called the anti-support of vi .
(
0 if xi 6= xj
6=
The cost function wij =
is an example of an anti-functional cost function.
1 otherwise
In this case, the anti-support of vi is itself. Note that for k = 1, anti-functional cost functions
represent anti-functional constraints.
Anti-functional cost functions are actually a specific case of semi-convex cost functions,
a class of cost functions that appear for example in temporal constraint networks with
preferences (Khatib, Morris, Morris, & Rossi, 2001).
Definition 5.6 Assume that the domain D(xj ) is contained in a set Dj totally ordered by
the order <j .
A function wij is semi-convex w.r.t. xi iff ‚àÄŒ≤ ‚àà [0, k], ‚àÄvi ‚àà Di , the set {vj ‚àà Dj :
wij (vi , vj ) ‚â• Œ≤}, called the Œ≤-support of vi , defines an interval over Dj according to <j .
Semi-convexity relies on the definition of intervals defined in a totally ordered discrete
set denoted Dj , and ordered by <j . Even if they may be identical, it is important to avoid
confusion between the order ‚â∫j over D(xj ), used to define interval domains for bounds
arc consistency, and the order <j over Dj used to define intervals for semi-convexity. In
order to guarantee constant time access to the minimum and maximum elements of D(xj )
according to <j (called the <j -bounds of the domain), we assume that <j =‚â∫j or <j =‚âªj 1 .
In this case, the <j -bounds and the domain bounds are identical.
One can simply check that anti-functional cost functions are indeed semi-convex: in
this case, the Œ≤-support of any value is either the whole domain (Œ≤ = 0), reduced to one
point (0 < Œ≤ ‚â§ Œ±) or to the empty set (otherwise). Another example is the cost function
wij = x2i ‚àí x2j which is semi-convex w.r.t. xi .
Proposition 5.7 The minimum of a cost function wij which is semi-convex w.r.t. one of
its variables can always be found in O(d).
Proof: We will first show that, if wij is semi-convex w.r.t. to one of its variables (let
say xi ), then for any value vi of xi , the cost function wij must be minimum at one of the
<j -bounds of Dj .
1. This restriction could be removed using for example a doubly-linked list data-structure over the values
in D(xj ), keeping the domain sorted according to <j and allowing constant time access and deletion but
this would be at the cost of linear space which we cannot afford in the context of BAC.

607

Zytnicki, Gaspin, de Givry & Schiex

Assume xi is set to vi . Let Œ≤b be the lowest cost reached on either of the two <j -bounds
of the domain. Since wij is semi-convex, then {vj ‚àà Dj : wij (vi , vj ) ‚â• Œ≤b } is an interval,
and thus every cost wij (vi , vj ) is not less than Œ≤b for every value of Dj . Therefore, at least
one of the two <j -bounds has a minimum cost.
In order to find the global minimum of wij , we can restrict ourselves to the <j -bounds
of the domain of xj for every value of xi . Therefore, only 2d costs need to be checked. 
From Proposition 5.1, we can conclude
Corollary 5.8 In a binary WCN, if all cost functions are functional, anti-functional or
semi-convex, the time complexity of enforcing BAC‚àÖ is O(n2 d2 ) only.
5.3 Monotonic and Convex Cost Functions
Definition 5.9 Assume that the domain D(xi ) (resp. D(xj )) is contained in a set Di (resp.
Dj ) totally ordered by the order <i (resp. <j ).
A cost function wij is monotonic iff:
‚àÄ(vi , vi‚Ä≤ , vj , vj‚Ä≤ ) ‚àà Di2 √ó Dj2 , vi‚Ä≤ ‚â§i vi ‚àß vj‚Ä≤ ‚â•j vj ‚áí wij (vi‚Ä≤ , vj‚Ä≤ ) ‚â§ wij (vi , vj )
(

0 if xi ‚â§ xj
is an example of a monotonic cost function.
1 otherwise
Monotonic cost functions are actually instances of a larger class of functions called convex
functions.
The cost function

‚â§
wij

=

Definition 5.10 A function wij is convex iff it is semi-convex w.r.t. each of its variables.
For example, wij = xi + xj is convex.
Proposition 5.11 The minimum of a convex cost function can always be found in constant
time.
Proof: Since the cost function is semi-convex w.r.t. each of its variable, we know from the
proof of Proposition 5.7 that it must reach a minimum cost on one of the <j -bounds of the
domain of xj and similarly for xi . There are therefore only four costs to check in order to
compute the minimum cost.

From Proposition 5.2, we conclude that
Corollary 5.12 In a binary WCN, if all cost functions are convex, then the time complexity
of enforcing BAC‚àÖ is O(n2 d) only.
One interesting example for a convex cost function is wij = max{xi ‚àí xj + cst, 0}. This
type of cost function, which can be efficiently filtered by BAC‚àÖ, may occur in temporal
reasoning problems and is also used in our RNA gene localization problem for specifying
preferred distances between elements of a gene.
608

Bounds Arc Consistency for Weighted CSPs

6. Comparison with Crisp Bounds Consistency
Petit et al. (2000) have proposed to transform WCNs into crisp constraint networks with
extra cost variables. In this transformation, every cost function is reified into a constraint,
which applies on the original cost function scope augmented by one extra variable representing the assignment cost. This reification of costs into domain variables transforms a WCN
in a crisp CN with more variables and augmented arities. As proposed by Petit et al., it
can be achieved using meta-constraints, i.e. logical operators applied to constraints. Given
this relation between WCNs and crisp CNs and the relation between BAC‚àÖ and bounds
consistency, it is natural to wonder how BAC‚àÖ enforcing relates to just enforcing bounds
consistency on the reified version of a WCN.
In this section we show that BAC‚àÖ is in some precise sense stronger than enforcing
bounds consistency on the reified form. This is a natural consequence of the fact that the
domain filtering in BAC is based on the combined cost of several cost functions instead of
taking each constraint separately in bounds consistency. We first define the reification process precisely. We then show that BAC‚àÖ can be stronger than the reified bounds consistency
on one example and conclude by proving that it can never be weaker.
The following example introduces the cost reification process.
Example 6.1 Consider the WCN in Figure 2(a). It contains two variables x1 and x2 , one
binary cost function w12 , and two unary cost functions w1 and w2 . For the sake of clarity,
every variable or constraint in the reified hard model, described on Figure 2(b), will be
indexed by the letter R.
First of all, we model every cost function by a hard constraint, and express that assigning
b to x1 yields a cost of 1. We create a new variable x1 C
R , the cost variable of w1 , that stores
the cost of any assignment of x1 . Then, we replace the unary cost function w1 by a binary
constraint c1R that involves x1 and x1 C
R , such that if a value v1 is assigned to x1 , then
x1 C
should
take
the
value
w
(v
).
We
do the same for the unary cost function w2 . The
1
1
R
idea is the same for the binary cost function w12 : we create a new variable x12 C
R , and we
replace w12 by a ternary constraint c12R , that makes sure that for any assignment of x1
and x2 to v1 and v2 respectively, x12 C
R takes the value w12 (v1 , v2 ). Finally, a global cost
C
constraint cR that states that the sum of the cost variables should be less than k is added:
C
C
x1 C
R + x2 R + x12 R < k. This completes the description of the reified cost hard constraint
network.
We can now define more formally the reification process of a WCN.
Definition 6.2 Consider the WCN P = hX , D, W, ki. Let reify(P) = hXR , DR , WR i be
the crisp CN such that:
‚Ä¢ the set XR contains one variable xi R for every variable xi ‚àà X , augmented with an
extra cost variable xS C
R per cost function wS ‚àà W ‚àí {w‚àÖ}.
‚Ä¢ the domains DR are:
‚Äì DR (xiR ) = D(xi ) for the xiR variables, with domain bounds lbiR and ubiR ,
C
C
‚Äì [lbS C
R , ubS R ] = [0, k ‚àí 1] for the xS R variables.

609

Zytnicki, Gaspin, de Givry & Schiex

x2 C
R

x1 C
R
x2R

x1R

0

0
a

a

b

b

1

1

2

2

k=3
x1

x2

a

0

1

a

b

1

0

b

x12 C
R
0

1

2

cC
R

(a) a small cost function
network

(b) the reified constraint network

Figure 2: A small cost function network and its reified counterpart.
‚Ä¢ the set WR of constraints contains:
‚Äì cS R = {(t, wS (t)) : t ‚àà ‚ÑìS , w‚àÖ ‚äï wS (t) < k}, with scope S ‚à™ {xS C
R }, for every cost
function wS ‚àà W,
P
C
‚Äì cC
wS ‚ààW xS R < k), an extra constraint that makes sure
R is defined as (w‚àÖ ‚äï
that the sum of the cost variables is strictly less than k.
It is simple to check that the problem reify(P) has a solution iff P has a solution and
the sum of the cost variables in a solution is the cost of the corresponding solution (defined
by the values of the xiR variables) in the original WCN.
Definition 6.3 Let P be a problem, ‚Ñì and ‚Ñì‚Ä≤ two local consistency properties. Let ‚Ñì(P)
be the problem obtained after filtering P by ‚Ñì. ‚Ñì is said to be not weaker than ‚Ñì‚Ä≤ iff ‚Ñì‚Ä≤ (P)
emptiness implies ‚Ñì(P) emptiness.
‚Ñì is said to be stronger than ‚Ñì‚Ä≤ iff it is not weaker than ‚Ñì‚Ä≤ , and if there exists a problem
P such that ‚Ñì‚Ä≤ (P) is not empty but ‚Ñì(P) is empty.
This definition is practically very significant since the emptiness of a filtered problem is
the event that generates backtracking in tree search algorithms used for solving CSP and
WCSP.
Example 6.4 Consider the WCN defined by three variables (x1 , x2 and x3 ) and two binary
cost functions (w12 and w13 ). D(x1 ) = {a, b, c, d}, D(x2 ) = D(x3 ) = {a, b, c} (we assume
that a ‚â∫ b ‚â∫ c ‚â∫ d). The costs of the binary cost functions are described in Figure 3.
Assume that k = 2 and w‚àÖ = 0.
One can check that the associated reified problem is already bounds consistent and
obviously not empty. For example, a support of the minimum bound of the domain of
x1 R w.r.t. c12 R is (a, a, 1), a support of its maximum bound is (d, a, 1). Supports of the
maximum and minimum bounds of the domain of x12 C
R w.r.t. c12R are (b, a, 0) and (a, a, 1)
respectively. Similarly, one can check that all other variable bounds are also supported on
all the constraints that involve them.
610

Bounds Arc Consistency for Weighted CSPs

a
a 1
(x2 ) b 1
c 1

(x1 )
b c
0 2
0 2
0 2

a
a 1
(x3 ) b 1
c 1

d
1
1
1

(x1 )
b c
2 0
2 0
2 0

d
1
1
1

Figure 3: Two cost matrices.
However, the original problem is not BAC since for example, the value a, the minimum
bound of the domain of x1 , does not satisfy the BAC property:
w‚àÖ ‚äï

X

wS ‚ààW,x1 ‚ààS



min

tS ‚àà‚ÑìS ,a‚ààtS


wS (tS ) < k

This means that the value a can be deleted by BAC filtering. By symmetry, the same applies
to the maximum bound of x1 and ultimately, the problem inconsistency will be proved by
BAC. This shows that bounds consistency on the reified problem cannot be stronger than
BAC on the original problem.
We will now show that BAC‚àÖ is actually stronger than bounds consistency applied
on the reified WCN. Because BAC‚àÖ consistency implies non-emptiness (since it requires
the existence of assignments of cost 0 in every cost function) we will start from any BAC‚àÖ
consistent WCN P (therefore not empty) and prove that filtering the reified problem reify(P)
by bounds consistency does not lead to an empty problem.
Lemma 6.5 Let P be a BAC‚àÖ consistent binary WCN. Then filtering reify(P) by bounds
consistency does not produce an empty problem.
Proof: We will prove here that bounds consistency will just reduce the maximum bounds
of the domains of the cost variables xS C
R to a non empty set and leave all other domains
unchanged.
More precisely, the final domain of xS C
R will become [0, max{wS (t) : t ‚àà ‚ÑìS , w‚àÖ ‚äïwS (t) <
k}]. Note that this interval is not empty because the network is BAC‚àÖ consistent which
means that every cost function has an assignment of cost 0 (by ‚àÖ-IC) and w‚àÖ < k (or else
the bounds of the domains could not have supports and the problem would not be BAC).
To prove that bounds consistency will not reduce the problem by more than this, we
simply prove that the problem defined by these domain reductions only is actually bounds
consistent.
All the bounds consistency required properties apply to the bounds of the domains of the
variables of reify(P). Let us consider every type of variable in this reified reduced problem:
‚Ä¢ reified variables xiR . Without loss of generality, assume that the minimum bound lbiR
of xiR is not bounds consistent (the symmetrical reasoning applies to the maximum
bound). This means it would have no support with respect to a given reified constraint
611

Zytnicki, Gaspin, de Givry & Schiex

cS R , xi ‚àà S. However, by BAC, we have
w‚àÖ ‚äï

min

t‚àà‚ÑìS ,lbiR ‚ààt

wS (t) < k

and so ‚àÉt ‚àà ‚ÑìS , lbiR ‚àà t,

wS (t) ‚â§ max{wS (t) : t ‚àà ‚ÑìS , w‚àÖ ‚äï wS (t) < k}

which means that lbi R is supported w.r.t. cS R .
‚Ä¢ cost variables. The minimum bound of all cost variables are always bounds consistent
w.r.t. the global constraint cC
R because this constraint is a ‚Äúless than‚Äù inequality.
Moreover, since the minimum bounds of the cost variables are set to 0, they are also
consistent w.r.t. the reified constraints, by the definition of ‚àÖ-inverse consistency.
Consider the maximum bound ubS C
R of a cost variable in the reduced reified problem.
Remember it is defined as max{wS (t) : t ‚àà ‚ÑìS , w‚àÖ ‚äïwS (t) < k}, and so w‚àÖ ‚äïubS C
R < k.
The minimum bounds of all other cost variables in the reified problem, which are 0,
C
C
form a support of ubS C
R w.r.t. the global constraint cR . So ubS R cannot be removed
by bounds consistency.

We will now prove the final assertion:
Proposition 6.6 BAC‚àÖ is stronger than bounds consistency.
Proof: Lemma 6.5 shows that BAC‚àÖ is not weaker than bounds consistency. Then,
example 6.4 is an instance where BAC, and therefore BAC‚àÖ is actually stronger than
bounds consistency after reification.

A filtering related to BAC‚àÖ could be achieved in the reified approach by an extra shaving
process where each variable is assigned to one of its domain bounds and this bound is deleted
if an inconsistency is found after enforcing bounds consistency (Lhomme, 1993).

7. Other Related Works
The Definition 3.1 of BAC is closely related to the notion of arc consistency counts introduced by Freuder and Wallace (1992) for Max-CSP processing. The Max-CSP can be seen
as a very simplified form of WCN where cost functions only generate costs of 0 or 1 (when
the associated constraint is violated). Our definition of BAC can be seen as an extension of
AC counts allowing dealing with arbitrary cost functions, including the usage of w‚àÖ and k,
and applied only to domain bounds as in bounds consistency. The addition of ‚àÖ-IC makes
BAC‚àÖ more powerful.
Dealing with large domains in Max-CSP has also been considered in the Range-Based
Algorithm, again designed for Max-CSP by Petit, ReÃÅgin, and BessieÃÄre (2002). This algorithm uses reversible directed arc consistency (DAC) counts and exploits the fact that
in Max-CSP, several successive values in a domain may have the same DAC counts. The
algorithm intimately relies on the fact that the problem is a Max-CSP problem, defined
by a set of constraints and actively uses bounds consistency dedicated propagators for the
constraints in the Max-CSP. In this case the number of different values reachable by the
DAC counters of a variable is bounded by the degree of the variable, which can be much
612

Bounds Arc Consistency for Weighted CSPs

smaller than the domain size. Handling intervals of values with a same DAC cost as one
value allows space and time savings. For arbitrary binary cost functions, the translation
into constraints could generate up to d2 constraints for a single cost function and makes the
scheme totally impractical.
Several alternative definition of bounds consistency exist in crisp CSPs (Choi et al.,
2006). Our extension to WCSP is based on bounds(D) or bounds(Z) consistencies (which
are equivalent on intervals). For numerical domains, another possible weaker definition
of bounds consistency is bounds(R) consistency, which is obtained by a relaxation to real
numbers. It has been shown by Choi et al. that bounds(R) consistency can be checked
in polynomial time on some constraints whereas bounds(D) or bounds(Z) is NP-hard (eg.
for linear equality). The use of this relaxed version in the WCSP context together with
intentional description of cost functions would have the side effect of extending the cost
domain from integer to real numbers. Because extensional or algorithmical description of
integer cost functions is more general and frequent in our problems, this possibility was
not considered. Since cost comparison is the fundamental mechanism used for pruning in
WCSP, a shift to real numbers for costs would require a safe floating number implementation
both in the local consistency enforcing algorithms and in the branch and bound algorithm.

8. Experimental Results
We experimented bounds arc consistency on two benchmarks translated into weighted CSPs.
The first benchmark is from AI planning and scheduling. It is a mission management
benchmark for agile satellites (Verfaillie & Lemaƒ±ÃÇtre, 2001; de Givry & Jeannin, 2006). The
maximum domain size of the temporal variables is 201. This reasonable size and the fact
that there are only binary cost functions allows us to compare BAC‚àÖ with strong local
consistencies such as EDAC*. Additionally, this benchmark has also been modeled using
the reified version of WCN, thus allowing for an experimental counterpart of the theoretical
comparison of Section 6.
The second benchmark comes from bioinformatics and models the problem of the localization of non-coding RNA molecules in genomes (TheÃÅbault et al., 2006; Zytnicki et al.,
2008). Our aim here is mostly to confirm that bounds arc consistency is useful and practical
on a real complex problem with huge domains, which can reach several millions.
8.1 A Mission Management Benchmark for Agile Satellites
We solved a simplified version described by de Givry and Jeannin (2006) of a problem of
selecting and scheduling earth observations for agile satellites. A complete description of
the problem is given by Verfaillie and Lemaƒ±ÃÇtre (2001). The satellite has a pool of candidate
photographs to take. It must select and schedule a subset of them on each pass above a
certain strip of territory. The satellite can only take one photograph at a time (disjunctive
scheduling). A photograph can only be taken during a time window that depends on the
location photographed. Minimal repositioning times are required between two consecutive
photographs. All physical constraints (time windows and repositioning times) must be
met, and the sum of the revenues of the selected photographs must be maximized. This is
equivalent to minimizing the ‚Äúrejected revenues‚Äù of the non selected photographs.
613

Zytnicki, Gaspin, de Givry & Schiex

Let N be the number of candidate photographs. We define N decision variables representing the acquisition starting times of the candidate photographs. The domain of each
variable is defined by the time window of its corresponding photograph plus an extra domain
value which represents the fact that the photograph is not selected. As proposed by de Givry
and Jeannin (2006), we create a binary hard constraint for every pair of photographs (resulting in a complete constraint graph) which enforces the minimal repositioning times if both
photographs are selected (represented by a disjunctive constraint). For each photograph, a
unary cost function associates its rejected revenue to the corresponding extra value.
In order to have a better filtering, we moved costs from unary cost functions inside
the binary hard constraints in a preprocessing step. This allows bounds arc consistency
filtering to exploit the revenue information and the repositioning times jointly, possibly
increasing w‚àÖ and the starting times of some photographs. To achieve this, for each variable
xi , the unary cost function wi is successively combined (using ‚äï) with each binary hard
‚Ä≤ defined
constraint wij that involves xi . This yields N ‚àí 1 new binary cost functions wij
‚Ä≤
as wij (t) = wij (t) ‚äï wi (t[xi ]), having both hard (+‚àû) and soft weights. These binary
‚Ä≤ replace the unary cost function w and the N ‚àí 1 original binary hard
cost functions wij
i
constraints wij . Notice that this transformation has the side effect of multiplying all soft
weights by N ‚àí 1. This does preserve the equivalence with the original problem since all
finite weights are just multiplied by the same constant (N ‚àí 1).
The search procedure is an exact depth-first branch-and-bound dedicated to scheduling
problems, using a schedule or postpone strategy as described by de Givry and Jeannin (2006)
which avoids the enumeration of all possible starting time values. No initial upper bound
was provided (k = +‚àû).
We generated 100 random instances for different numbers of candidate photographs
(N varying from 10 to 30)2 . We compared BAC‚àÖ (denoted by BAC0 in the experimental
results) with EDAC* (Heras et al., 2005) (denoted by EDAC*). Note that FDAC* and VAC
(applied in preprocessing and during search, in addition to EDAC*) were also tested on
these instances, but did not improve over EDAC* (FDAC* was slightly faster than EDAC*
but developed more search nodes and VAC was significantly slower than EDAC*, without
improving w‚àÖ in preprocessing). OSAC is not practical on this benchmark (for N = 20,
it has to solve a linear problem with 50, 000 variables and about 4 million constraints).
All the algorithms are using the same search procedure. They are implemented in the
toulbar2 C++ solver3 . Finding the minimum cost of the previously-described binary cost
functions (which are convex if we consider the extra domain values for rejected photographs
separately), is done in constant time for BAC‚àÖ. It is done in time O(d2 ) for EDAC*
(d = 201).
We also report the results obtained by maintaining bounds consistency on the reified
problem using meta-constraints as described by de Givry and Jeannin (2006), using the
claire/Eclair C++ constraint programming solver (de Givry, Jeannin, Josset, Mattioli,
Museux, & SaveÃÅant, 2002) developed by THALES (denoted by B-consistency).
The results are presented in Figure 4, using a log-scale. These results were obtained on
a 3 GHz Intel Xeon with 4 GB of RAM. Figure 4 shows the mean CPU time in seconds and
the mean number of backtracks performed by the search procedure to find the optimum
2. These instances are available at http://www.inra.fr/mia/ftp/T/bep/.
3. See http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/ToolBarIntro.

614

Bounds Arc Consistency for Weighted CSPs

Satellite benchmark
10000

EDAC*
B consistency
BAC0

Cpu time in seconds

1000
100
10
1
0.1
0.01
0.001
1e-04
10

15
20
25
Number of candidate photographs

30

Satellite benchmark
1e+08

B consistency
BAC0
EDAC*

Number of backtracks

1e+07
1e+06
100000
10000
1000
100
10
10

15

20

25

30

Number of candidate photographs

Figure 4: Comparing various local consistencies on a satellite benchmark. Cpu-time (top)
and number of backtracks (bottom) are given.

615

Zytnicki, Gaspin, de Givry & Schiex

and prove optimality as the problem size increases. In the legends, algorithms are sorted
by increasing efficiency.
The analysis of experimental results shows that BAC‚àÖ was up to 35 times faster than
EDAC* while doing only 25% more backtracks than EDAC* (for N = 30, no backtrack results are reported as EDAC* does not solve any instance within the time limit of 6 hours).
It shows that bounds arc consistency can prune almost as many search nodes as a stronger
local consistency does in much less time for temporal reasoning problems where the semantic of the cost functions can be exploited, as explained in Section 5. The second fastest
approach was bounds consistency on the reified representation which was at least 2.3 worse
than BAC‚àÖ in terms of speed and number of backtracks when N ‚â• 25. This is a practical confirmation of the comparison of Section 6. The reified approach used with bounds
consistency introduces Boolean decision variables for representing photograph selection and
uses a criteria defined as a linear function of these variables. Contrarily to BAC‚àÖ, bounds
consistency is by definition unable to reason simultaneously on the combination of several
constraints to prune the starting times.
8.2 Non-coding RNA Gene Localization
A non-coding RNA (ncRNA) gene is a functional molecule composed of smaller molecules,
called nucleotides, linked together by covalent bonds. There are four types of these nucleotides, commonly identified by a single letter: A, U, G and C. Thus, an RNA can be
represented as a word built from the four letters. This sequence defines what is called the
primary structure of the RNA molecule.
RNA molecules have the ability to fold back on themselves by developing interactions
between nucleotides, forming pairs. The most frequently interacting pairs are: a G interacts
with a C, or a U interacts with an A. A sequence of such interactions forms a structure
called a helix. Helices are a fundamental structural element in ncRNA genes and are the
basis for more complex structures. The set of interactions is often displayed by a graph
where vertices represent nucleotides and edges represent either covalent bonds linking successive nucleotides (represented as plain lines in Figure 5) or interacting nucleotide pairs
(represented as dotted lines). This representation is usually called the molecule‚Äôs secondary
structure. See the graph of a helix in Figure 5(a).
The set of ncRNAs that have a common biological function is called a family. The
signature of a gene family is the set of conserved elements either in the sequence or the
secondary structure. It can be expressed as a collection of properties that must be satisfied
by a set of regions occurring on a sequence. Given the signature of a family, the problem we
are interested in involves searching for new members of a gene family in existing genomes,
where these members are in fact the set of regions appearing in the genome which satisfy the
signature properties. Genomic sequences are themselves long texts composed of nucleotides.
They can be thousand of nucleotides long for the simplest organisms up to several hundred
million nucleotides for the more complex ones. The problem of searching for an occurrence
of a gene signature in a genomic sequence is NP-complete for complex combinations of helix
structures (Vialette, 2004).
In order to find ncRNAs, we can build a weighted constraint network that scans a
genome, and detects the regions of the genome where the signature elements are present
616

Bounds Arc Consistency for Weighted CSPs

A U A
C

A G C G U C

G

U C G C A G

helix

C
G A U

A G A C UA U U
xi
xj

loop

(cost: 1)
(b)
pattern(xi , xj , ACGUA)
cost function.

(a) An helix with its loop.

G

xi

U C

U A G

A G

xl

cost

xj

A G C

k

xk
(cost: 2)

(c) The helix(xi , xj , xk , xl , 6) cost
function.

The

0

xj ‚àí xi
d1 d2

d3

d4

(d)
The
cost
profile
spacer(xi , xj , d1 , d2 , d3 , d4 )
cost
tion.

of
func-

Figure 5: Examples of signature elements with their cost functions.
and correctly positioned. The variables are the positions of the signature elements in the
sequence. The size of the domains is the size of the genomic sequence. Cost functions
enforce the presence of the signature elements between the positions taken by the variables
involved. Examples of cost functions are given in Figure 5.
‚Ä¢ The pattern(xi , xj , p) function states that a fixed word p, given as parameter, should
be found between the positions indicated by the variables xi and xj . The cost given
by the function is the edit distance between the word found at xi :xj and the word p
(see the cost function pattern with the word ACGUA in Figure 5(b)).
‚Ä¢ The helix(xi , xj , xk , xl , m) function states that the nucleotides between positions xi
and xj should be able to bind with the nucleotides between xk and xl . Parameter
m specifies a minimum helix length. The cost given is the number of mismatches or
nucleotides left unmatched (see the helix function with 5 interacting nucleotide pairs
in Figure 5(c)).
‚Ä¢ Finally, the function, spacer(xi , xj , d1 , d2 , d3 , d4 ) specifies a favorite range of distances
between positions xi and xj using a trapezoidal cost function as shown in Figure 5(d).
See the work of Zytnicki et al. (2008) for a complete description of the cost functions.
Because of the sheer domain size, and given that the complex pattern matching oriented
cost functions do not have any specific property that could speedup filtering, BAC alone
has been used for filtering these cost functions (Zytnicki et al., 2008). The exception is the
617

Zytnicki, Gaspin, de Givry & Schiex

piecewise linear spacer cost function: its minimum can be computed in constant time for
BAC‚àÖ enforcement. The resulting C++ solver is called DARN!4 .
Size
# of solutions
AC*
Time
# of backtracks
BAC
Time (sec.)
# of backtracks

10k
32

50k
33

100k
33

500k
33

1M
41

4.9M
274

1hour 25min.
93

44 hours
101

-

-

-

-

0.016
93

0.036
101

0.064
102

0.25
137

0.50
223

2.58
1159

Table 1: Searching all the solutions of a tRNA motif in Escherichia coli genome.
A typical benchmark for the ncRNA localization problem is the transfer RNA (tRNA)
localization. The tRNA signature (Gautheret, Major, & Cedergren, 1990) can be modelled
by 22 variables, 3 nucleotide words, 4 helices, and 7 spacers. DARN! searched for all the
solutions with a cost strictly lower than the maximum cost k = 3. Just to illustrate the
absolute necessity of using bounds arc consistency in this problem, we compared bounds
arc consistency enforcement with AC* (Larrosa, 2002) on sub-sequences of the genome of
Escherichia coli, which is 4.9 million nucleotides long. Because of their identical space
complexity and because they have not been defined nor implemented on non-binary cost
functions (helix is a quaternarycost function), DAC, FDAC or EDAC have not been tested
(see the work of SaÃÄnchez et al., 2008, however for an extension of FDAC to ternary cost
functions).
The results are displayed in Table 1. For different beginning sub-sequences of the complete sequence, we report the size of the sub-sequence in which the signature is searched
for (10k is a sequence of 10,000 nucleotides), as well as the number of solutions found.
We also show the number of backtracks and the time spent on a 3 GHz Intel Xeon with
2 GB. A ‚Äú-‚Äù means the instance could not be solved due to memory reasons, and despite
memory optimizations. BAC solved the complete sequence in less than 3 seconds. BAC
is approximately 300, 000 (resp. 4, 400, 000) times faster than AC* for the 10k (resp. 50k)
sub-sequence. More results on other genomes and ncRNA signatures can be found in the
work of Zytnicki et al. (2008).
The reason of the superiority of BAC over AC* is twofold. First, AC* needs to store all
the unary costs for every variable and projects costs from binary cost functions to unary
cost functions. Thus, the space complexity of AC* is at least O(nd). For very large domains
(in our experiments, greater than 100,000 values), the computer cannot allocate a sufficient
memory and the program is aborted. For the same kind of projection, BAC only needs to
store the costs of the bounds of the domains, leading to a space complexity of O(n).
Second, BAC does not care about the interior values and focuses on the bounds of the
domains only. On the other hand, AC* projects all the binary costs to all the interior values,
4. DARN!,
and
several
genomic
http://carlit.toulouse.inra.fr/Darn/.

sequences

618

and

family

signatures

are

available

at

Bounds Arc Consistency for Weighted CSPs

which takes a lot of time, but should remove more values and detect inconsistencies earlier.
However, Table 1 shows that the number of backtracks performed by AC* and BAC are
the same. This can be explained as follows. Due to the nature of the cost functions used in
these problems, the supports of the bounds of the domains of the variables usually are the
bounds of the other variables. Thus, removing the values which are inside the domains, as
AC* does, do not help removing the bounds of the variables. As a consequence, the bounds
founds by BAC are the same as those found by AC*. This explains why enforcing of AC*
generally does not lead to new domain wipe out compared to BAC, and finding the support
inside the bounds of the domains is useless.
Notice that the spacer cost functions dramatically reduce the size of the domains. When
a single variable is assigned, all the other domain sizes are dramatically reduced, and the
instance becomes quickly tractable. Moreover, the helix constraint has the extra knowledge
of a maximum distance djk between its variables xj and xk (see Fig. 5(c)) which bounds the
time complexity of finding the minimum cost w.r.t. djk and not the length of the sequence.

9. Conclusions and Future Work
We have presented here new local consistencies for weighted CSPs dedicated to large domains as well as algorithms to enforce these properties. The first local consistency, BAC,
has a time complexity which can be easily reduced if the semantics of the cost function
is appropriate. A possible enhancement of this property, ‚àÖ-IC, has also been presented.
Our experiments showed that maintaining bounds arc consistency is much better than AC*
for problems with large domains, such as ncRNA localization and scheduling for Earth observation satellites. This is due to the fact that AC* cannot handle problems with large
domains, especially because of its high memory complexity, but also because BAC‚àÖ behaves
particularly well with specific classes of cost functions.
Similarly to bounds consistency, which is implemented on almost all state-of-the-art
CSP solvers, this new local property has been implemented in the open source toulbar2
WCSP solver.5
BAC, BAC‚àÖ and ‚àÖ-inverse consistency allowed us to transfer bounds consistency CSP to
weighted CSP, including improved propagation for specific classes of binary cost functions.
Our implementation for RNA gene finding is also able to filter non-binary constraints. It
would therefore be quite natural to try to define efficient algorithms for enforcing BAC,
BAC‚àÖ or ‚àÖ-inverse consistency on specific cost functions of arbitrary arity such as the soft
global constraints derived from All-Diff, GCC or regular (ReÃÅgin, 1994; Van Hoeve, Pesant,
& Rousseau, 2006). This line of research has been recently explored by Lee and Leung
(2009).
Finally, another interesting extension of this work would be to better exploit the connection between BAC and bounds consistency by exploiting the idea of Virtual Arc Consistency
introduced by Cooper et al. (2008). The connection established by Virtual AC between crisp
CNs and WCNs is much finer grained than in the reification approach considered by Petit
et al. (2000) and could provide strong practical and theoretical results.
5. Available at http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/ToolBarIntro.

619

Zytnicki, Gaspin, de Givry & Schiex

References
Apt, K. (1999). The essence of constraint propagation. Theoretical computer science, 221 (12), 179‚Äì210.
BessieÃÄre, C., & ReÃÅgin, J.-C. (2001). Refining the basic constraint propagation algorithm.
In Proc. of IJCAI‚Äô01, pp. 309‚Äì315.
Chellappa, R., & Jain, A. (1993). Markov Random Fields: Theory and Applications. Academics Press.
Choi, C. W., Harvey, W., Lee, J. H. M., & Stuckey, P. J. (2006). Finite domain bounds
consistency revisited. In Proc. of Australian Conference on Artificial Intelligence, pp.
49‚Äì58.
Cooper, M., & Schiex, T. (2004). Arc consistency for soft constraints. Artificial Intelligence,
154, 199‚Äì227.
Cooper, M. C., de Givry, S., SaÃÄnchez, M., Schiex, T., & Zytnicki, M. (2008). Virtual arc
consistency for weighted CSP.. In Proc. of AAAI‚Äô2008.
Cooper, M. C., de Givry, S., & Schiex, T. (2007). Optimal soft arc consistency. In Proc. of
IJCAI‚Äô07, pp. 68‚Äì73.
de Givry, S., & Jeannin, L. (2006). A unified framework for partial and hybrid search
methods in constraint programming. Computer & Operations Research, 33 (10), 2805‚Äì
2833.
de Givry, S., Jeannin, L., Josset, F., Mattioli, J., Museux, N., & SaveÃÅant, P. (2002). The
THALES constraint programming framework for hard and soft real-time applications.
The PLANET Newsletter, Issue 5 ISSN 1610-0212, pages 5-7.
Freuder, E., & Wallace, R. (1992). Partial constraint satisfaction. Artificial Intelligence,
58, 21‚Äì70.
Gautheret, D., Major, F., & Cedergren, R. (1990). Pattern searching/alignment with RNA
primary and secondary structures: an effective descriptor for tRNA. Comp. Appl.
Biosc., 6, 325‚Äì331.
Heras, F., Larrosa, J., de Givry, S., & Zytnicki, M. (2005). Existential arc consistency:
Getting closer to full arc consistency in weighted CSPs. In Proc. of IJCAI‚Äô05, pp.
84‚Äì89.
Khatib, L., Morris, P., Morris, R., & Rossi, F. (2001). Temporal constraint reasoning with
preferences. In Proc. of IJCAI‚Äô01, pp. 322‚Äì327.
Larrosa, J. (2002). Node and arc consistency in weighted CSP. In Proc. of AAAI‚Äô02, pp.
48‚Äì53.
Larrosa, J., & Schiex, T. (2004). Solving weighted CSP by maintaining arc-consistency.
Artificial Intelligence, 159 (1-2), 1‚Äì26.
Lee, J., & Leung, K. (2009). Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction. In Proc. of IJCAI‚Äô09.
Lhomme, O. (1993). Consistency techniques for numeric CSPs. In Proc. of IJCAI‚Äô93, pp.
232‚Äì238.
620

Bounds Arc Consistency for Weighted CSPs

Meseguer, P., Rossi, F., & Schiex, T. (2006). Soft constraints. In Rossi, F., van Beek, P.,
& Walsh, T. (Eds.), Handbook of constraint programming, Foundations of Artificial
Intelligence, chap. 9, pp. 281‚Äì328. Elsevier.
Petit, T., ReÃÅgin, J.-C., & BessieÃÄre, C. (2000). Meta-constraints on violations for over constrained problems. In Proc. of ICTAI‚Äô00, pp. 358‚Äì365.
Petit, T., ReÃÅgin, J. C., & BessieÃÄre, C. (2002). Range-based algorithm for Max-CSP. In
Proc. of CP‚Äô02, pp. 280‚Äì294.
ReÃÅgin, J.-C. (1994). A filtering algorithm for constraints of difference in CSPs. In Proc. of
AAAI‚Äô94, pp. 362‚Äì367.
SaÃÄnchez, M., de Givry, S., & Schiex, T. (2008). Mendelian error detection in complex
pedigrees using weighted constraint satisfaction techniques. Constraints, 13 (1-2), 130‚Äì
154.
Sandholm, T. (1999). An Algorithm for Optimal Winner Determination in Combinatorial
Auctions. In Proc. of IJCAI‚Äô99, pp. 542‚Äì547.
Schiex, T. (2000). Arc consistency for soft constraints. In Proc. of CP‚Äô00, pp. 411‚Äì424.
Tarski, A. (1955). A lattice-theoretical fixpoint theorem and its applications. Pacific Journal
of Mathematics, 5 (2), 285‚Äì309.
TheÃÅbault, P., de Givry, S., Schiex, T., & Gaspin, C. (2006). Searching RNA motifs and their
intermolecular contacts with constraint networks. Bioinformatics, 22 (17), 2074‚Äì80.
Van Hentenryck, P., Deville, Y., & Teng, C.-M. (1992). A generic arc-consistency algorithm
and its specializations. Artificial Intelligence, 57 (2‚Äì3), 291‚Äì321.
Van Hoeve, W., Pesant, G., & Rousseau, L. (2006). On global warming: Flow-based soft
global constraints. Journal of Heuristics, 12 (4), 347‚Äì373.
Verfaillie, G., & Lemaƒ±ÃÇtre, M. (2001). Selecting and scheduling observations for agile satellites: some lessons from the constraint reasoning community point of view. In Proc.
of CP‚Äô01, pp. 670‚Äì684.
Vialette, S. (2004). On the computational complexity of 2-interval pattern matching problems. Theoretical Computer Science, 312 (2-3), 223‚Äì249.
Zytnicki, M., Gaspin, C., & Schiex, T. (2008). DARN! A soft constraint solver for RNA
motif localization. Constraints, 13 (1-2), 91‚Äì109.

621

